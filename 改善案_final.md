# SEO記事自動生成システム 改善案（最終版）

> ClaudeCode + Codex 協議結果

---

## エグゼクティブサマリ

仕様書は**非常に練られた設計**であり、特に以下の3原則は堅牢：
- フォールバック全面禁止
- 決定性重視
- マルチテナント物理分離

改善案はこれらの原則を尊重しつつ、**運用上の実用性を高める**方向で整理。

---

## 最優先改善項目（Top 10）

| 順位 | 改善案 | カテゴリ | 理由 |
|------|--------|----------|------|
| 1 | プロンプトインジェクション対策 | セキュリティ | 仕様書に言及なし。必須 |
| 2 | テナントDB運用自動化 | 運用基盤 | 物理分離の前提だが実装未定義 |
| 3 | 部分再実行機能 | 運用効率 | 失敗時の全runやり直しは非効率 |
| 4 | 並列工程(3A/3B/3C)エラーハンドリング詳細化 | 設計補完 | 仕様書で曖昧な部分 |
| 5 | テスト戦略明文化 + モックLLM実装 | 品質基盤 | テストなき実装は危険 |
| 6 | ヘルスチェックエンドポイント | 運用監視 | 依存サービス状態の可視化 |
| 7 | コスト追跡強化 | ビジネス | run/テナント単位の集計 |
| 8 | 品質メトリクス（4本柱準拠） | 品質可視化 | LLMO/CTA等の測定 |
| 9 | 決定性検証自動化 | Temporal保証 | Replay Testの自動化 |
| 10 | プロンプトバージョニング強化 | 品質改善 | A/Bテスト対応 |

---

## 詳細改善案

### 1. セキュリティ

#### 1.1 プロンプトインジェクション対策【最優先】
**現状**: 仕様書に言及なし（重大な見落とし）

**実装案**:
- 工程-1（UI入力）と工程0（LLM初回呼び出し）の間にサニタイズレイヤー挿入
- 入力長制限（例: キーワード100文字以内）
- 危険パターンのフィルタリング
- サニタイズルールもバージョン管理
- 弾いた入力を監査ログに記録（攻撃検知）

#### 1.2 出力の機密情報検出
- 生成コンテンツに含まれる可能性のある機密情報の自動検出
- 検出時にアラート or 承認待ち

#### 1.3 Rate Limiting
- テナント単位のAPIレートリミット
- 同時実行run数の制限
- LLM API呼び出しのスロットリング

#### 1.4 監査ログ改ざん防止
```sql
-- DELETE/UPDATE を禁止
CREATE TRIGGER prevent_audit_log_modification
BEFORE UPDATE OR DELETE ON audit_logs
FOR EACH ROW EXECUTE FUNCTION raise_exception();
```
- 外部ログ転送（CloudWatch Logs等）
- HMAC署名付きログ

---

### 2. 運用基盤

#### 2.1 テナントDB運用自動化【最優先】
**現状**: 物理分離を採用するが運用ツールが未定義

**必要機能**:
| 機能 | 説明 |
|------|------|
| 自動作成 | 新規テナント追加時にDB作成、マイグレーション、接続情報登録 |
| 一括マイグレーション | 全テナントDBにスキーマ変更を適用 |
| バックアップ/リストア | テナント単位、PITR対応 |
| データ削除（GDPR） | テナント解約時の完全削除 |

**CLI案**:
```bash
seo-gen tenant create --name "customer-a"
seo-gen tenant migrate --all
seo-gen tenant backup --tenant-id "xxx"
seo-gen tenant delete --tenant-id "xxx" --confirm
```

#### 2.2 部分再実行機能【最優先】
**現状**: リトライはstep単位だが、途中から再開の仕組みが不明確

**実装案**:
- 任意の工程から再開可能
- 再開時に依存工程の成果物存在 + digest検証
- UI上で「ここから再実行」ボタン

**Codex指摘**:
> Temporal Workflowの決定性を保つため、再実行は「新しいrun_idで開始し、既存成果物を参照する」方式が望ましい

#### 2.3 ヘルスチェックエンドポイント
```
GET /health          # 基本的な生存確認
GET /health/detailed # 依存サービスの状態
```

**チェック対象**:
- DB（共通管理DB + テナントDB接続プール）
- MinIO
- Temporal（Worker登録状況、キュー長）
- LLM API各プロバイダー

---

### 3. 設計補完

#### 3.1 並列工程(3A/3B/3C)エラーハンドリング詳細化【高優先】
**現状**: 「失敗分のみリトライ」とあるが具体的挙動が不明

**明確化案**:
| ケース | 挙動 |
|--------|------|
| 3A成功、3B失敗、3C成功 | 3Bのみリトライ（最大3回） |
| 3A/3B/3C全失敗 | 全リトライ。全再失敗でrun失敗 |
| 3Aが3回失敗後 | 3B/3C続行せず停止（3つ揃わないと承認待ちに進めない） |

```python
# 実装案
results = []
for attempt in range(3):
    pending = [s for s in ["3a", "3b", "3c"] if s not in results]
    new_results = await asyncio.gather(
        *[activity(s) for s in pending],
        return_exceptions=True
    )
    results.extend([r for r in new_results if not isinstance(r, Exception)])
    if len(results) == 3:
        break
if len(results) < 3:
    raise WorkflowFailedError("Step3 partially failed")
```

#### 3.2 工程間依存の明示化
- 依存関係をコードで明示（例: `step4.depends_on = ["step3a", "step3b", "step3c"]`）
- DAG検証を起動時に実行
- 循環依存を静的に検出

#### 3.3 LangGraph State肥大化対策
**Codex分析**: 既に`path/digest`参照を採用しており、現時点では問題化しにくい

**潜在リスク対策**:
- `validation_reports`/`errors`リストの上限設定
- checkpointごとに古いデータを削除
- State最大サイズの警告機構

---

### 4. 品質基盤

#### 4.1 テスト戦略明文化【高優先】
**現状**: 「破壊パターンテストスイート」のみ言及

**推奨テスト戦略**:
| レベル | LLM | 頻度 | 目的 |
|--------|-----|------|------|
| ユニット | モック | 毎commit | ロジック検証 |
| 統合 | モック | 毎PR | ワークフロー構造検証 |
| E2E（smoke） | モック | 毎PR | 起動・疎通確認 |
| E2E（本番） | 実LLM | 毎週 | 実運用相当の検証 |
| カオステスト | 実LLM | 毎月 | JSON破損、タイムアウト等の異常系 |

**追加テスト**:
- 決定性テスト（同一入力で複数回実行、digest一致確認）
- フォールバック不在テスト（コードに`fallback`文字列がないことを静的検証）
- マルチテナント分離テスト

#### 4.2 モックLLM実装方針
**現状**: 「mock_pack明示指定時のみ動作」とあるが実装未定義

**実装案**:
1. **ファイルベースモック**: `mocks/llm_responses/step0_keyword.json`等
2. **決定論的生成**: run_idからシード値を生成し、バリエーション選択
3. **遅延シミュレーション**: 実LLMのレイテンシを再現

#### 4.3 決定性検証自動化
- Temporal Replay APIで過去履歴を再実行
- 非決定的コード（`datetime.now()`, `random.random()`）の静的検出
- PR時に自動実行

---

### 5. 可観測性

#### 5.1 コスト追跡強化
**現状**: `token_usage`はstepsテーブルに記録

**拡張案**:
- `llm_models`テーブルに`cost_per_1k_tokens`追加
- run単位/テナント単位のコスト集計ビュー
- Storage使用量も追跡（MinIO容量）
- ツールコスト（SERP API等）も統合
- コスト閾値アラート

#### 5.2 品質メトリクス（4本柱準拠）
**仕様書の「4本柱」に基づくメトリクス**:
| 柱 | メトリクス |
|----|-----------|
| LLMO | 400-600 tokens/section の範囲チェック |
| KGI | CTA配置（Early/Mid/Final）の確認 |
| 神経科学 | 概念数3以内の検証 |
| 行動経済学 | 6原則の適用確認 |

**その他**:
- 一次情報引用数（データアンカー要件）
- セクション独立性評価

#### 5.3 分散トレーシング
- OpenTelemetry対応
- Temporal → LangGraph → LLM のend-to-endトレース

---

### 6. 開発者体験（DX）

#### 6.1 CLIツール拡充
```bash
seo-gen run create --keyword "xxx"
seo-gen run status <id>
seo-gen run approve <id>
seo-gen run retry <id> --step step3b
```

#### 6.2 デバッグ支援
- プロンプトのレンダリング結果プレビュー
- LLM応答のリプレイ機能
- Step入出力のdiff表示

#### 6.3 ローカル開発モード
- 単一工程のみの実行モード
- ホットリロード対応

---

### 7. ビジネスロジック（低優先）

#### 7.1 複数承認ポイント
**Codex見解**: 現時点では過剰。段階的導入を推奨。

**ロードマップ**:
1. MVP: 工程3後のみ承認
2. v1.1: 工程6.5後の承認を**オプション**として追加
3. v2.0: 任意工程に承認ポイント設定可能な汎用機構

#### 7.2 並列化拡張の検討
**Codex分析**:
| 工程ペア | 並列化可否 | 備考 |
|---------|----------|------|
| 工程7A/7B | 可能 | 7Aで複数候補生成→7Bで選択も可能 |
| 工程8/9 | 不可 | 9は8の結果に依存 |
| 工程0/1 | 不可 | 1は0の出力に依存 |

#### 7.3 出力フォーマット拡張
- WordPress直接投稿対応
- PDF出力

---

### 8. 仕様書自体の改善

#### 8.1 用語の統一
| 現状の混在 | 推奨統一 |
|----------|---------|
| 「工程」vs「step」 | 「工程（step）」 |
| 「成果物」vs「artifact」vs「output」 | 「成果物（artifact）」 |
| 「承認」vs「approve」 | 「承認（approval）」 |

→ 仕様書冒頭に「用語対応表」を追加

#### 8.2 エラーケースの網羅
各工程で発生しうるエラーパターンの列挙:
| 工程 | エラーケース | 期待挙動 |
|------|------------|---------|
| 全工程 | LLM API Rate Limit | exponential backoffで5分間リトライ→失敗で停止 |
| 工程1 | SERP結果0件 | 即座に失敗 |
| 工程5 | 一次情報URL全て404 | 失敗（警告のみで続行は禁止） |
| 工程8 | ファクトチェック矛盾検出 | 却下推奨（自動修正は禁止） |

#### 8.3 非機能要件の追加
| 項目 | 推奨値 | 備考 |
|------|--------|------|
| 可用性 | 95%（月次） | ローカル運用のため控えめ |
| レイテンシ | 工程0〜10合計 60分以内 | 承認待ち時間除く |
| スループット | 同時10 run | 単一Temporalクラスタの限界 |
| データ保持期間 | 完了run: 1年、失敗run: 3ヶ月 | |

---

## フォールバック禁止の運用課題と対策

**Codex指摘**: 課題あり。ただし設計思想は正しい。

### 予想される課題
| シナリオ | 現状の挙動 | 運用負荷 |
|---------|----------|---------|
| LLM API一時障害 | 即座にfail | 高（夜間対応待ち） |
| JSON破損 | リトライ3回→停止 | 中（許容範囲） |
| SERP API障害 | 即座にfail | 高（外部依存） |

### 推奨対策（フォールバックではない）
1. **自動リトライ強化**:
   ```python
   @retry(stop=stop_after_delay(300), wait=wait_exponential())
   async def call_llm(...): pass
   ```
2. **通知機構**: Temporal Activity失敗時にSlack/Email通知
3. **オンコール体制**: 夜間・休日の障害対応要員

### 長期対策（Phase 2以降）
- Circuit Breaker: 連続失敗時に一時停止、復旧後に自動再開
- Dead Letter Queue: 失敗runを一時保管、障害復旧後に一括再実行

---

## 実装ロードマップ

### Phase 0: 基盤強化（2週間）
- テナントDB運用ツール実装
- テスト戦略明文化
- モックLLM実装

### Phase 1: セキュリティ・運用基盤（3週間）
- プロンプトインジェクション対策
- 部分再実行機能
- ヘルスチェックエンドポイント
- 並列工程エラーハンドリング詳細化

### Phase 2: 可観測性・品質（2週間）
- コスト追跡強化
- 品質メトリクス（4本柱準拠）
- 決定性検証自動化

### Phase 3: 開発者体験（2週間）
- プロンプトバージョニング強化
- デバッグ支援機能
- CLIツール拡充

### Phase 4: 最適化（2週間）
- キャッシュ戦略
- 複数承認ポイント（オプション）
- 出力フォーマット拡張

---

## まとめ

仕様書の設計は堅牢。改善案は以下に集約：

1. **見落とし補完**: プロンプトインジェクション対策、テナントDB運用
2. **曖昧部分の明確化**: 並列工程エラーハンドリング、エラーケース網羅
3. **運用効率化**: 部分再実行、ヘルスチェック、コスト追跡
4. **品質基盤**: テスト戦略、モックLLM、決定性検証
