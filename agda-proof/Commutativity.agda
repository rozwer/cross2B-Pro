{-
================================================================================
  掛け算の交換法則の証明 
================================================================================

【命題】
  自然数の掛け算において、書け順（掛ける順序）は結果に影響しない。
  すなわち、任意の自然数 m, n に対して m × n = n × m が成り立つ。

【数学的意味】
  - 「3 × 5」と「5 × 3」は同じ結果になる
  - 掛け算の左右を入れ替えても等しい（交換法則）
  - これは「書け順が固定されない」ことの形式的証明

【証明戦略】
  自然数の構造的帰納法を用いる。
  自然数は zero または suc n（n の次の数）として定義されるため、
  これらの場合について証明すれば、すべての自然数について成り立つ。

================================================================================
-}

module source where

{-
================================================================================
  自然数の定義 (Definition of Natural Numbers)
================================================================================
【定義】
  自然数 ℕ は以下の2つの構成子で帰納的に定義される：
  - zero : 0 を表す
  - suc  : n の次の数（n + 1）を表す

【例】
  0 = zero
  1 = suc zero
  2 = suc (suc zero)
  3 = suc (suc (suc zero))
================================================================================
-}
data ℕ : Set where
  zero : ℕ
  suc  : ℕ → ℕ

{-
================================================================================
  等価性の定義 (Propositional Equality)
================================================================================
【定義】
  _≡_ は命題的等価性を表す。
  refl（反射性）は「x ≡ x」を証明する唯一の構成子。

【Curry-Howard 対応】
  - 型 `x ≡ y` は命題「x と y は等しい」に対応
  - 値 `refl` はその証明に対応
================================================================================
-}
data _≡_ {A : Set} : A → A → Set where
  refl : {x : A} → x ≡ x

infix 4 _≡_

{-
--------------------------------------------------------------------------------
  対称性 (Symmetry)
--------------------------------------------------------------------------------
【命題】 x ≡ y → y ≡ x
【意味】 x = y ならば y = x
--------------------------------------------------------------------------------
-}
sym : {A : Set} {x y : A} → x ≡ y → y ≡ x
sym refl = refl

{-
--------------------------------------------------------------------------------
  推移性 (Transitivity)
--------------------------------------------------------------------------------
【命題】 x ≡ y → y ≡ z → x ≡ z
【意味】 x = y かつ y = z ならば x = z
--------------------------------------------------------------------------------
-}
trans : {A : Set} {x y z : A} → x ≡ y → y ≡ z → x ≡ z
trans refl refl = refl

{-
--------------------------------------------------------------------------------
  合同性 (Congruence)
--------------------------------------------------------------------------------
【命題】 x ≡ y → f x ≡ f y
【意味】 x = y ならば f(x) = f(y)（関数は等しい入力に対し等しい出力を返す）
--------------------------------------------------------------------------------
-}
cong : {A B : Set} {x y : A} → (f : A → B) → x ≡ y → f x ≡ f y
cong f refl = refl

{-
================================================================================
  加法の定義 (Definition of Addition)
================================================================================
【定義】
  zero    + n = n           -- 0 + n = n（左単位元）
  (suc m) + n = suc (m + n) -- (1 + m) + n = 1 + (m + n)

【例】
  2 + 3 = suc (suc zero) + suc (suc (suc zero))
        = suc (suc zero + suc (suc (suc zero)))
        = suc (suc (zero + suc (suc (suc zero))))
        = suc (suc (suc (suc (suc zero))))
        = 5
================================================================================
-}
_+_ : ℕ → ℕ → ℕ
zero    + n = n
(suc m) + n = suc (m + n)

infixl 6 _+_

{-
================================================================================
  乗法の定義 (Definition of Multiplication)
================================================================================
【定義】
  zero    * n = zero        -- 0 × n = 0
  (suc m) * n = n + (m * n) -- (1 + m) × n = n + m × n

【注意】
  この定義は左側の引数で再帰しているため、
  左から0を掛ける場合（0 * n = 0）は定義から自明だが、
  右から0を掛ける場合（n * 0 = 0）は帰納法で証明が必要。

【例】
  2 × 3 = suc (suc zero) * suc (suc (suc zero))
        = 3 + (1 × 3)
        = 3 + (3 + (0 × 3))
        = 3 + (3 + 0)
        = 6
================================================================================
-}
_*_ : ℕ → ℕ → ℕ
zero    * n = zero
(suc m) * n = n + (m * n)

infixl 7 _*_

{-
================================================================================
  加法の補題 (Lemmas for Addition)
================================================================================
交換法則の証明に必要な加法の性質を先に証明する。
================================================================================
-}

{-
--------------------------------------------------------------------------------
  右単位元 (Right Identity)
--------------------------------------------------------------------------------
【命題】 ∀ n. n + 0 = n
【意味】 任意の数に右から0を足すと元の数になる

【証明】 n についての帰納法
  - 基底 (n = 0): 0 + 0 = 0（定義より）
  - 帰納 (n = suc n'): suc n' + 0 = suc (n' + 0) = suc n'（帰納法の仮定より）
--------------------------------------------------------------------------------
-}
+-identityʳ : (n : ℕ) → n + zero ≡ n
-- 基底: 0 + 0 = 0
+-identityʳ zero    = refl
-- 帰納: suc n + 0 = suc (n + 0) = suc n
+-identityʳ (suc n) = cong suc (+-identityʳ n)

{-
--------------------------------------------------------------------------------
  右サクセサ (Right Successor)
--------------------------------------------------------------------------------
【命題】 ∀ m n. m + suc n = suc (m + n)
【意味】 m + (n + 1) = (m + n) + 1

【証明】 m についての帰納法
  - 基底 (m = 0): 0 + suc n = suc n = suc (0 + n)
  - 帰納 (m = suc m'): suc m' + suc n = suc (m' + suc n) = suc (suc (m' + n))
--------------------------------------------------------------------------------
-}
+-sucʳ : (m n : ℕ) → m + suc n ≡ suc (m + n)
-- 基底: 0 + suc n = suc n = suc (0 + n)
+-sucʳ zero    n = refl
-- 帰納: suc m + suc n = suc (m + suc n) = suc (suc (m + n))
+-sucʳ (suc m) n = cong suc (+-sucʳ m n)

{-
--------------------------------------------------------------------------------
  加法の交換法則 (Commutativity of Addition)
--------------------------------------------------------------------------------
【命題】 ∀ m n. m + n = n + m
【意味】 加法の順序を入れ替えても結果は同じ

【証明】 m についての帰納法
  - 基底 (m = 0): 0 + n = n = n + 0（右単位元より）
  - 帰納 (m = suc m'):
      suc m' + n = suc (m' + n)     -- 定義より
                 = suc (n + m')     -- 帰納法の仮定
                 = n + suc m'       -- 右サクセサより
--------------------------------------------------------------------------------
-}
+-comm : (m n : ℕ) → m + n ≡ n + m
-- 基底: 0 + n = n = n + 0
+-comm zero    n = sym (+-identityʳ n)
-- 帰納: suc m + n = suc (m + n) = suc (n + m) = n + suc m
+-comm (suc m) n = trans (cong suc (+-comm m n)) (sym (+-sucʳ n m))

{-
--------------------------------------------------------------------------------
  加法の結合法則 (Associativity of Addition)
--------------------------------------------------------------------------------
【命題】 ∀ m n p. (m + n) + p = m + (n + p)
【意味】 加法の括弧の位置を変えても結果は同じ

【証明】 m についての帰納法
  - 基底 (m = 0): (0 + n) + p = n + p = 0 + (n + p)
  - 帰納 (m = suc m'):
      (suc m' + n) + p = suc (m' + n) + p = suc ((m' + n) + p)
                       = suc (m' + (n + p))  -- 帰納法の仮定
                       = suc m' + (n + p)
--------------------------------------------------------------------------------
-}
+-assoc : (m n p : ℕ) → (m + n) + p ≡ m + (n + p)
-- 基底: (0 + n) + p = n + p = 0 + (n + p)
+-assoc zero    n p = refl
-- 帰納: (suc m + n) + p = suc ((m + n) + p) = suc (m + (n + p)) = suc m + (n + p)
+-assoc (suc m) n p = cong suc (+-assoc m n p)

{-
================================================================================
  乗法の補題 (Lemmas for Multiplication)
================================================================================
-}

{-
--------------------------------------------------------------------------------
  補題1: 右ゼロ則 (Right Zero Law)
--------------------------------------------------------------------------------
【命題】 ∀ n. n × 0 = 0
【意味】 任意の数に右から0を掛けると0になる

【注意】
  乗法の定義 `zero * n = zero` より、左から0を掛ける場合は自明。
  しかし右から0を掛ける場合は帰納法が必要。

【証明】 n についての帰納法
  - 基底 (n = 0): 0 × 0 = 0（定義より）
  - 帰納 (n = suc n'):
      suc n' × 0 = 0 + n' × 0  -- 定義より
                 = 0 + 0        -- 帰納法の仮定
                 = 0
--------------------------------------------------------------------------------
-}
*-zeroʳ : (n : ℕ) → n * zero ≡ zero
-- 基底: 0 × 0 = 0
*-zeroʳ zero    = refl
-- 帰納: suc n × 0 = 0 + n × 0 = n × 0 = 0
*-zeroʳ (suc n) = *-zeroʳ n

{-
--------------------------------------------------------------------------------
  補題2: 右サクセサ則 (Right Successor Law)
--------------------------------------------------------------------------------
【命題】 ∀ m n. m × (1 + n) = m + m × n
【意味】 右側の数が1増えると、結果は左側の数だけ増える

【直感的理解】
  m × (n + 1) = m × n + m を変形すると
  m × (1 + n) = m + m × n となる
  （Agda では suc n = 1 + n）

【証明】 m についての帰納法
  - 基底 (m = 0): 0 × suc n = 0 = 0 + 0 × n
  - 帰納 (m = suc m'): 複数のステップで証明（下記参照）
--------------------------------------------------------------------------------
-}
*-sucʳ : (m n : ℕ) → m * suc n ≡ m + m * n
-- 基底: 0 × suc n = 0 = 0 + 0 × n
*-sucʳ zero    n = refl
-- 帰納: (suc m) × suc n = suc m + suc m × n
*-sucʳ (suc m) n =
  let -- step1: 帰納法の仮定を適用
      -- suc n + m × suc n = suc n + (m + m × n)
      step1 : suc n + m * suc n ≡ suc n + (m + m * n)
      step1 = cong (λ x → suc n + x) (*-sucʳ m n)

      -- step2: 定義より suc n + x = suc (n + x)
      step2 : suc n + (m + m * n) ≡ suc (n + (m + m * n))
      step2 = refl

      -- step3: 結合法則の逆適用
      -- suc (n + (m + m × n)) = suc ((n + m) + m × n)
      step3 : suc (n + (m + m * n)) ≡ suc ((n + m) + m * n)
      step3 = cong suc (sym (+-assoc n m (m * n)))

      -- step4: 加法の交換法則を適用
      -- suc ((n + m) + m × n) = suc ((m + n) + m × n)
      step4 : suc ((n + m) + m * n) ≡ suc ((m + n) + m * n)
      step4 = cong (λ x → suc (x + m * n)) (+-comm n m)

      -- step5: 結合法則を適用
      -- suc ((m + n) + m × n) = suc (m + (n + m × n))
      step5 : suc ((m + n) + m * n) ≡ suc (m + (n + m * n))
      step5 = cong suc (+-assoc m n (m * n))

      -- step6: 定義より suc (m + x) = suc m + x
      step6 : suc (m + (n + m * n)) ≡ suc m + (n + m * n)
      step6 = refl
  in trans step1 (trans step3 (trans step4 step5))

{-
================================================================================
  主定理: 掛け算の交換法則 (Multiplication Commutativity)
================================================================================
【命題】 ∀ m n. m × n = n × m
【意味】 掛け算の順序を入れ替えても結果は同じ
【換言】 「書け順は固定されない」＝どちらの順序で書いても等価

【Agda 型との対応】
  *-comm : (m n : ℕ) → m * n ≡ n * m

  この型は「任意の自然数 m, n を与えると、m × n = n × m の証明を返す関数」
  を表している。型チェックが通れば、この命題が真であることが保証される。

【証明の流れ】
  m についての帰納法：
  - 基底 (m = 0): 0 × n = 0 = n × 0 ... 補題1（右ゼロ則）より
  - 帰納 (m = suc m'):
      suc m' × n = n + m' × n     ... 定義より
                 = n + n × m'     ... 帰納法の仮定
                 = n × suc m'     ... 補題2（右サクセサ則）より
================================================================================
-}
*-comm : (m n : ℕ) → m * n ≡ n * m
-- 基底: 0 × n = 0 = n × 0（補題1の対称性）
*-comm zero    n = sym (*-zeroʳ n)
-- 帰納: suc m × n = n × suc m
*-comm (suc m) n =
  let -- 帰納法の仮定: m × n = n × m
      ih : m * n ≡ n * m
      ih = *-comm m n

      -- step1: 帰納法の仮定を適用
      -- n + m × n = n + n × m
      step1 : n + m * n ≡ n + n * m
      step1 = cong (λ x → n + x) ih

      -- step2: 補題2の逆適用
      -- n + n × m = n × suc m
      step2 : n + n * m ≡ n * suc m
      step2 = sym (*-sucʳ n m)
  in trans step1 step2

{-
================================================================================
  具体例による確認 (Concrete Examples)
================================================================================
以下は具体的な数値での交換法則の適用例。
型チェックが通ることで、各等式が正しいことが保証される。
================================================================================
-}

-- 例: 3 × 5 = 5 × 3
-- suc (suc (suc zero)) = 3
-- suc (suc (suc (suc (suc zero)))) = 5
example : (suc (suc (suc zero))) * (suc (suc (suc (suc (suc zero)))))
        ≡ (suc (suc (suc (suc (suc zero))))) * (suc (suc (suc zero)))
example = *-comm (suc (suc (suc zero))) (suc (suc (suc (suc (suc zero)))))
