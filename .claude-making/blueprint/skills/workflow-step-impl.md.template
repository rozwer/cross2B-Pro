---
name: workflow-step-impl
description: ワークフロー工程（ステップ）の実装ガイド
---

# /workflow-step-impl - 工程実装ガイド

> ワークフローの各工程（ステップ）を実装するためのガイドライン

---

## 概要

このスキルは `options.json` の `workflow_framework` 設定に関係なく適用される、
工程（ステップ）実装の共通ガイドラインを提供します。

---

## 工程の基本構造

### 入出力の契約

```
{{STEP_IO_CONTRACT}}
```

<!-- 使用例:
# 入力の定義（Pydantic）
class StepInput(BaseModel):
    """工程への入力"""
    run_id: str
    tenant_id: str
    previous_output_ref: OutputReference | None = None
    parameters: dict = Field(default_factory=dict)

    class Config:
        extra = "forbid"  # 余分なフィールドを禁止

# 出力の定義
class StepOutput(BaseModel):
    """工程からの出力"""
    output_ref: OutputReference  # 成果物への参照
    summary: str                  # 要約（UI表示用）
    metrics: dict                 # メトリクス（token使用量など）

    class Config:
        extra = "forbid"

# 出力参照の定義
class OutputReference(BaseModel):
    """外部ストレージへの参照"""
    path: str           # storage://{tenant}/{run}/{step}/output.json
    digest: str         # sha256 ハッシュ
    size: int           # バイト数
    created_at: datetime
-->

### 工程のインターフェース

```
{{STEP_INTERFACE}}
```

<!-- 使用例:
from abc import ABC, abstractmethod

class BaseStep(ABC):
    """工程の基底クラス"""

    step_name: str  # 工程名（例: "step1", "step3a"）

    @abstractmethod
    async def validate_input(self, input: StepInput) -> ValidationResult:
        """入力の検証"""
        pass

    @abstractmethod
    async def execute(self, input: StepInput) -> StepOutput:
        """工程の実行"""
        pass

    @abstractmethod
    async def validate_output(self, output: StepOutput) -> ValidationResult:
        """出力の検証"""
        pass

    async def run(self, input: StepInput) -> StepOutput:
        """工程の実行（テンプレートメソッド）"""
        # 入力検証
        validation = await self.validate_input(input)
        if not validation.is_valid:
            raise StepValidationError(validation.errors)

        # 冪等性チェック
        existing = await self.check_existing_output(input)
        if existing:
            return existing

        # 実行
        output = await self.execute(input)

        # 出力検証
        validation = await self.validate_output(output)
        if not validation.is_valid:
            raise StepValidationError(validation.errors)

        return output
-->

---

## 冪等性の実装

### 同一入力 → 同一出力

```
{{STEP_IDEMPOTENCY}}
```

<!-- 使用例:
class IdempotentStep(BaseStep):
    """冪等性を保証する工程"""

    async def check_existing_output(self, input: StepInput) -> StepOutput | None:
        """既存の出力をチェック"""
        # 入力のハッシュを計算
        input_digest = self.compute_input_digest(input)

        # 既存の出力を検索
        path = f"storage/{input.tenant_id}/{input.run_id}/{self.step_name}/output.json"
        metadata = await storage.get_metadata(path)

        if metadata and metadata.get("input_digest") == input_digest:
            # 同一入力の出力が存在する場合はそれを返す
            return await self.load_output(path)

        return None

    def compute_input_digest(self, input: StepInput) -> str:
        """入力のハッシュを計算"""
        # 再現性のためソートして JSON 化
        normalized = json.dumps(input.dict(), sort_keys=True)
        return hashlib.sha256(normalized.encode()).hexdigest()
-->

### 部分的な再実行

```
{{STEP_PARTIAL_RERUN}}
```

<!-- 使用例:
class RerunableStep(BaseStep):
    """部分的な再実行をサポートする工程"""

    async def execute_with_checkpoint(
        self,
        input: StepInput,
        checkpoint: StepCheckpoint | None = None
    ) -> StepOutput:
        """チェックポイントから再開可能な実行"""

        if checkpoint:
            # チェックポイントから状態を復元
            state = await self.restore_state(checkpoint)
            start_index = checkpoint.progress_index
        else:
            state = self.initial_state(input)
            start_index = 0

        # 処理を継続
        for i, item in enumerate(input.items[start_index:], start=start_index):
            result = await self.process_item(item, state)
            state = self.update_state(state, result)

            # 定期的にチェックポイントを保存
            if i % 10 == 0:
                await self.save_checkpoint(input, state, i)

        return self.finalize(state)
-->

---

## エラーハンドリング

### カスタム例外

```
{{STEP_EXCEPTIONS}}
```

<!-- 使用例:
class StepError(Exception):
    """工程エラーの基底クラス"""
    def __init__(self, message: str, step_name: str, details: dict = None):
        super().__init__(message)
        self.step_name = step_name
        self.details = details or {}

class StepValidationError(StepError):
    """入出力の検証エラー"""
    pass

class StepExecutionError(StepError):
    """実行時エラー"""
    pass

class StepRetryableError(StepError):
    """リトライ可能なエラー"""
    def __init__(self, message: str, step_name: str, retry_after: int = None, **kwargs):
        super().__init__(message, step_name, **kwargs)
        self.retry_after = retry_after  # 秒

class StepFatalError(StepError):
    """リトライ不可能な致命的エラー"""
    pass
-->

### エラー処理パターン

```
{{STEP_ERROR_HANDLING}}
```

<!-- 使用例:
async def execute_with_error_handling(self, input: StepInput) -> StepOutput:
    """エラーハンドリング付きの実行"""
    try:
        return await self.execute(input)

    except ValidationError as e:
        # 入力の問題 → リトライ不可
        raise StepFatalError(
            message=f"Validation failed: {e}",
            step_name=self.step_name,
            details={"validation_errors": e.errors()}
        )

    except ExternalAPIError as e:
        if e.status_code in (429, 503):
            # レート制限または一時的エラー → リトライ可能
            raise StepRetryableError(
                message=f"API temporarily unavailable: {e}",
                step_name=self.step_name,
                retry_after=e.retry_after
            )
        else:
            # その他の API エラー → リトライ不可
            raise StepFatalError(
                message=f"API error: {e}",
                step_name=self.step_name,
                details={"status_code": e.status_code}
            )

    except Exception as e:
        # 予期しないエラー → ログして再スロー
        logger.exception(f"Unexpected error in {self.step_name}")
        raise StepExecutionError(
            message=str(e),
            step_name=self.step_name
        )
-->

---

## テスト方法

### ユニットテスト

```
{{STEP_UNIT_TEST}}
```

<!-- 使用例:
import pytest
from unittest.mock import AsyncMock, patch

class TestMyStep:
    """工程のユニットテスト"""

    @pytest.fixture
    def step(self):
        return MyStep()

    @pytest.fixture
    def valid_input(self):
        return StepInput(
            run_id="test-run-123",
            tenant_id="tenant-456",
            parameters={"key": "value"}
        )

    @pytest.mark.asyncio
    async def test_execute_success(self, step, valid_input):
        """正常系のテスト"""
        output = await step.run(valid_input)

        assert output.output_ref is not None
        assert output.summary != ""
        assert output.metrics.get("token_count", 0) > 0

    @pytest.mark.asyncio
    async def test_execute_invalid_input(self, step):
        """異常系のテスト（不正な入力）"""
        invalid_input = StepInput(
            run_id="",  # 空のrun_id
            tenant_id="tenant-456"
        )

        with pytest.raises(StepValidationError):
            await step.run(invalid_input)

    @pytest.mark.asyncio
    async def test_idempotency(self, step, valid_input):
        """冪等性のテスト"""
        output1 = await step.run(valid_input)
        output2 = await step.run(valid_input)

        assert output1.output_ref.digest == output2.output_ref.digest
-->

### 統合テスト

```
{{STEP_INTEGRATION_TEST}}
```

<!-- 使用例:
@pytest.mark.integration
class TestMyStepIntegration:
    """工程の統合テスト（実際の依存関係を使用）"""

    @pytest.fixture
    async def setup_storage(self):
        """ストレージのセットアップ"""
        async with test_storage_context() as storage:
            yield storage

    @pytest.fixture
    async def setup_db(self):
        """DBのセットアップ"""
        async with test_db_context() as db:
            yield db

    @pytest.mark.asyncio
    async def test_end_to_end(self, setup_storage, setup_db):
        """エンドツーエンドのテスト"""
        step = MyStep(storage=setup_storage, db=setup_db)

        input_data = StepInput(
            run_id="integration-test-run",
            tenant_id="test-tenant"
        )

        output = await step.run(input_data)

        # ストレージに保存されていることを確認
        stored = await setup_storage.get(output.output_ref.path)
        assert stored is not None

        # DBに記録されていることを確認
        record = await setup_db.get_step_record(
            input_data.run_id,
            step.step_name
        )
        assert record.status == "completed"
-->

### モックの使用

```
{{STEP_MOCKING}}
```

<!-- 使用例:
@pytest.mark.asyncio
async def test_with_mocked_llm(step, valid_input):
    """LLMをモックしたテスト"""

    mock_response = LLMResponse(
        content="Mocked response",
        usage={"input_tokens": 100, "output_tokens": 200}
    )

    with patch.object(step.llm, 'generate', new_callable=AsyncMock) as mock_generate:
        mock_generate.return_value = mock_response

        output = await step.run(valid_input)

        mock_generate.assert_called_once()
        assert output.metrics["token_count"] == 300
-->

---

## ディレクトリ構成

```
{{STEP_DIRECTORY_STRUCTURE}}
```

<!-- 使用例:
apps/
├── worker/
│   ├── steps/
│   │   ├── __init__.py
│   │   ├── base.py           # BaseStep クラス
│   │   ├── exceptions.py     # カスタム例外
│   │   ├── step1/
│   │   │   ├── __init__.py
│   │   │   ├── step.py       # Step1 実装
│   │   │   ├── schemas.py    # 入出力スキーマ
│   │   │   └── validators.py # バリデータ
│   │   ├── step2/
│   │   │   └── ...
│   │   └── step3/
│   │       ├── step3a/
│   │       ├── step3b/
│   │       └── step3c/
│   └── tests/
│       ├── unit/
│       │   └── steps/
│       │       └── test_step1.py
│       └── integration/
│           └── steps/
│               └── test_step1_integration.py
-->

---

## 使用方法

```bash
# 新規工程の作成
/workflow-step-impl create <step_name>

# 工程のスキャフォールド生成
/workflow-step-impl scaffold <step_name> --type <llm|transform|validate>

# 工程のテスト実行
/workflow-step-impl test <step_name>

# 工程の検証
/workflow-step-impl validate <step_name>
```

---

## チェックリスト

### 実装時の確認事項

```
[ ] 入出力のスキーマを定義した
[ ] 入力のバリデーションを実装した
[ ] 出力のバリデーションを実装した
[ ] 冪等性を実装した（同一入力 → 同一出力）
[ ] エラーハンドリングを実装した
[ ] 大容量データは外部ストレージに保存
[ ] メトリクス（token使用量など）を記録
[ ] ユニットテストを作成した
[ ] 統合テストを作成した
```

### 禁止事項

```
[ ] ハードコード（テスト期待値をそのまま return）
[ ] スタブ/空実装（pass のみ、NotImplementedError）
[ ] 状態に大きなデータを直接保存
[ ] 例外の握りつぶし
[ ] フォールバックの実装
```

---

## 関連スキル

| スキル | 用途 |
|--------|------|
| `/{{WORKFLOW_FRAMEWORK_LOWER}}-fundamentals` | フレームワーク基礎 |
| `/{{WORKFLOW_FRAMEWORK_LOWER}}-patterns` | よく使うパターン |
| `/{{WORKFLOW_FRAMEWORK_LOWER}}-persistence` | 状態の永続化 |

---

## 変数一覧

| 変数名 | 説明 | 必須 |
|--------|------|------|
| `{{WORKFLOW_FRAMEWORK_LOWER}}` | フレームワーク名（小文字） | NO |
| `{{STEP_IO_CONTRACT}}` | 入出力契約の例 | YES |
| `{{STEP_INTERFACE}}` | 工程インターフェースの例 | YES |
| `{{STEP_IDEMPOTENCY}}` | 冪等性実装の例 | YES |
| `{{STEP_PARTIAL_RERUN}}` | 部分再実行の例 | NO |
| `{{STEP_EXCEPTIONS}}` | カスタム例外の例 | YES |
| `{{STEP_ERROR_HANDLING}}` | エラーハンドリングの例 | YES |
| `{{STEP_UNIT_TEST}}` | ユニットテストの例 | YES |
| `{{STEP_INTEGRATION_TEST}}` | 統合テストの例 | NO |
| `{{STEP_MOCKING}}` | モックの例 | NO |
| `{{STEP_DIRECTORY_STRUCTURE}}` | ディレクトリ構成 | NO |
